{"version":3,"file":"static/js/802.7cec52e0.chunk.js","mappings":"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","sources":["components/ThreeContext.tsx","components/controller/OutMaterial.tsx","uses/three/useCamera.ts","uses/three/useLight.ts","uses/three/useRender.ts","uses/three/useShader.ts","uses/useAddObject.ts","uses/useRequestAnimationFrame.ts","utils/glsl.ts"],"sourcesContent":["import React, { createContext, FC, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\r\nimport * as THREE from 'three';\r\n\r\ninterface ThreeContextProps {\r\n    renderer: THREE.WebGLRenderer | null,\r\n    scene: THREE.Scene | null,\r\n}\r\n\r\nconst initialContext: ThreeContextProps = {\r\n    renderer: null,\r\n    scene: null,\r\n};\r\n\r\nconst ThreeContext = createContext<ThreeContextProps>(initialContext);\r\n\r\nexport const useThreeContext = () => useContext(ThreeContext);\r\nexport const ThreeProvider: FC = ({ children }) => {\r\n    const size = useSize();\r\n    const elCanvas = useRef<HTMLCanvasElement>(null)\r\n    const [threeRenderer, setThreeRenderer] = useState<THREE.WebGLRenderer | null>(null);\r\n\r\n    const scene = useMemo(() => {\r\n        return new THREE.Scene();\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (threeRenderer == null) return;\r\n        if (size == null) return;\r\n        threeRenderer.setPixelRatio(window.devicePixelRatio);\r\n        threeRenderer.setSize(size.width, size.height);\r\n    }, [threeRenderer, size])\r\n\r\n    useEffect(() => {\r\n        if (elCanvas.current == null) throw new Error('');\r\n        const renderer = new THREE.WebGLRenderer({\r\n            canvas: elCanvas.current,\r\n            antialias: true,\r\n        });\r\n        setThreeRenderer(renderer);\r\n        return () => {\r\n            setThreeRenderer(null);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <ThreeContext.Provider\r\n            value={{\r\n                renderer: threeRenderer,\r\n                scene,\r\n            }}\r\n        >\r\n            <canvas ref={elCanvas} />\r\n            {children}\r\n        </ThreeContext.Provider>\r\n    );\r\n};\r\n\r\nfunction useSize() {\r\n    const [size, setSize] = useState<{width: number, height: number}>();\r\n\r\n    const resize = useCallback(() => {\r\n        setSize({\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        })\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        resize();\r\n        window.addEventListener('resize', resize);\r\n        return () => {\r\n            window.removeEventListener('resize', resize);\r\n        };\r\n    }, [resize]);\r\n\r\n    return size;\r\n}","import React, { FC, useEffect, useMemo } from 'react';\r\nimport * as THREE from 'three';\r\nimport { useCamera } from '../../uses/three/useCamera';\r\nimport { useDirectionalLight } from '../../uses/three/useLight';\r\nimport { useRender } from '../../uses/three/useRender';\r\nimport { useAddObject } from '../../uses/useAddObject';\r\nimport { useRequestAnimationFrame } from '../../uses/useRequestAnimationFrame';\r\nimport { useThreeContext } from '../ThreeContext';\r\nimport { useShader } from '../../uses/three/useShader';\r\nimport { deserialize, fbm, hsv2rgb, random, rotate2d, simplex2d, simplex2dFractal } from '../../utils/glsl';\r\n\r\n// ref https://www.wpc-store.com/f/feature/detail/?p=2223\r\nconst vertexShader = `\r\nuniform float u_time;\r\nuniform vec2 u_resolution;\r\nvarying vec2 vUv;\r\n\r\nvoid main()\t{\r\n    vec3 p = position;\r\n    vUv = uv - .5;\r\n    vUv += .5;\r\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(p, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShader = `\r\nuniform float u_time;\r\nvarying vec2 vUv;\r\nuniform vec2 u_resolution;\r\n#include <fog_pars_fragment>\r\n\r\n${\r\n    deserialize([\r\n        random(),\r\n        simplex2d(),\r\n        fbm(5, { noiseFunc: simplex2dFractal() }),\r\n        hsv2rgb(),\r\n        rotate2d(),\r\n    ])\r\n}\r\n\r\nvoid main()\t{\r\n    vec3 color;\r\n    color = vec3(0.0);\r\n    vec2 p = (vUv - vec2(0.5)) * 2.0 * 2.;\r\n\r\n    float a = (fbm(\r\n        p\r\n        + fbm(\r\n            p\r\n            + fbm(\r\n                p\r\n    ))) + 1.0) / 2.0;\r\n\r\n    color.x = a * 0.1 + 0.0 + fbm(p);\r\n    color.y = 1.0;\r\n    color.z = a * 0.8 + 0.5 + fbm(p);\r\n\r\n    vec3 c = hsv2rgb(color);\r\n    c = vec3(a);\r\n\r\n    gl_FragColor = vec4(c, 1.0);\r\n    #include <fog_fragment>\r\n}\r\n`;\r\n\r\nexport const OutMaterial: FC = () => {\r\n    const { scene } = useThreeContext();\r\n    const camera = useCamera({ z: -400 })\r\n    const render = useRender(camera);\r\n\r\n    useEffect(() => {\r\n        if (scene == null) return;\r\n        const light = new THREE.AmbientLight(0x222200, 1.0);\r\n        scene.add(light);\r\n\r\n        return () => {\r\n            scene.remove(light);\r\n        };\r\n    }, [scene]);\r\n\r\n    const light1 = useDirectionalLight({ x: -200, y: -100, z: 100, intensity: 1, color: 0x006666 })\r\n    useAddObject(scene, light1);\r\n\r\n    const light2 = useDirectionalLight({ x: 150, y: 100, z: -50, intensity: 1, color: 0xFFFFBB })\r\n    useAddObject(scene, light2);\r\n\r\n    const [mesh, registerUniform] = useShader({ fragmentShader, vertexShader });\r\n    useEffect(() => {\r\n        mesh.scale.x = 3.0;\r\n        mesh.scale.y = 3.0;\r\n    }, [mesh]);\r\n    useAddObject(scene, mesh);\r\n\r\n\r\n    const updateUniformTime = registerUniform('u_time', 0);\r\n    registerUniform('u_resolution', [window.innerWidth, window.innerHeight]);\r\n\r\n    const look = useMemo(() => {\r\n        const lookatPosition = new THREE.Vector3(0, 0, 0);\r\n        return lookatPosition;\r\n    }, []);\r\n\r\n    useRequestAnimationFrame((time) => {\r\n        camera.lookAt(look);\r\n        updateUniformTime(time);\r\n        render();\r\n    });\r\n\r\n    return <></>;\r\n};\r\n","import { useEffect, useRef } from \"react\";\r\nimport * as THREE from 'three';\r\n\r\nexport const useCamera = ({x = 0, y = 0, z = 0}: {x?: number, y?: number, z?: number}) => {\r\n    const refCamera = useRef(new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight));\r\n\r\n    useEffect(() => {\r\n        refCamera.current.position.x = x;\r\n    }, [x]);\r\n\r\n    useEffect(() => {\r\n        refCamera.current.position.y = y;\r\n    }, [y]);\r\n    useEffect(() => {\r\n        refCamera.current.position.z = z;\r\n    }, [z]);\r\n\r\n    return refCamera.current;\r\n}","import { useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\n\r\nexport const useDirectionalLight = ({\r\n    x = 0,\r\n    y = 0,\r\n    z = 0,\r\n    color = 0xFFFFFF,\r\n    intensity = 1,\r\n}: {\r\n    x?: number,\r\n    y?: number,\r\n    z?: number,\r\n    color?: number,\r\n    intensity?: number,\r\n}) => {\r\n    const refLight = useRef(new THREE.DirectionalLight());\r\n    useEffect(() => {\r\n        refLight.current.intensity = intensity;\r\n    }, [intensity]);\r\n    useEffect(() => {\r\n        refLight.current.color.set(color);\r\n    }, [color]);\r\n    useEffect(() => {\r\n        refLight.current.position.x = x;\r\n    }, [x]);\r\n    useEffect(() => {\r\n        refLight.current.position.y = y;\r\n    }, [y]);\r\n    useEffect(() => {\r\n        refLight.current.position.z = z;\r\n    }, [z]);\r\n\r\n    return refLight.current;\r\n}\r\n// const light =  new THREE.DirectionalLight(0xFFFFBB, 1);\r\n// const light =  new THREE.DirectionalLight(0x006666, 1);","import { useThreeContext } from \"../../components/ThreeContext\";\r\nimport * as THREE from 'three';\r\nimport { useCallback } from \"react\";\r\n\r\nexport const useRender = (camera: THREE.Camera) => {\r\n    const { scene, renderer } = useThreeContext();\r\n\r\n    return useCallback(() => {\r\n        if (renderer == null || scene == null) return;\r\n        renderer.render(scene, camera);\r\n    }, [camera, renderer, scene]);\r\n};\r\n","import { useCallback, useEffect, useMemo } from 'react';\r\nimport * as THREE from 'three';\r\n\r\nexport const useShader = ({\r\n    fragmentShader = '',\r\n    vertexShader = '',\r\n    fog = false,\r\n    geometry = new THREE.PlaneBufferGeometry(100, 100, 10, 10),\r\n}: {\r\n    fragmentShader: string,\r\n    vertexShader: string,\r\n    uniforms?: { [uniform: string]: THREE.IUniform },\r\n    fog?: boolean;\r\n    geometry?: THREE.BufferGeometry,\r\n}): [THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial>, (key: string, initialValue: number | number[]) => (value: number | number[]) => void] => {\r\n    const material = useMemo(() => new THREE.ShaderMaterial({\r\n        transparent: true,\r\n        depthTest: true,\r\n        // depthWrite: true,\r\n    }), []);\r\n    useEffect(() => { material.vertexShader = vertexShader }, [material, vertexShader]);\r\n    useEffect(() => { material.fragmentShader = fragmentShader }, [material, fragmentShader]);\r\n    useEffect(() => { material.fog = fog }, [material, fog]);\r\n\r\n    const mesh = useMemo(() => {\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n        return mesh\r\n    }, [material, geometry]);\r\n\r\n    const registerUniform = useCallback((key: string, initialValue: number | number[]) => {\r\n        material.uniforms[key] = { value: initialValue };\r\n        const updateUniform = (value: number | number[]) => { material.uniforms[key].value = value; };\r\n        return updateUniform;\r\n    }, [material]);\r\n\r\n    return [\r\n        mesh,\r\n        registerUniform,\r\n    ];\r\n}","import { useEffect } from 'react';\r\nimport * as THREE from 'three';\r\n\r\nexport const useAddObject = (parent: THREE.Object3D | null, children: THREE.Object3D | null) => {\r\n    useEffect(() => {\r\n        if (parent == null || children == null) return;\r\n        parent.add(children);\r\n        return () => {\r\n            parent.remove(children);\r\n        }\r\n    }, [parent, children]);\r\n};","import { useEffect, useRef } from \"react\";\r\n\r\ntype AnimationFrame = (time: number, deltaTime: number) => void;\r\n\r\nexport function loopAnimation(cb: AnimationFrame) {\r\n    let isCancel = false;\r\n    let id = 0;\r\n    const main: AnimationFrame = (time) => {\r\n        if (isCancel) return;\r\n        id = window.requestAnimationFrame((time) => {\r\n            main(time, 0);\r\n        });\r\n        cb(time, 0);\r\n    }\r\n\r\n    id = window.requestAnimationFrame((time) => {\r\n        main(time, 0)\r\n    });\r\n    return () => {\r\n        isCancel = true;\r\n        window.cancelAnimationFrame(id)\r\n    };\r\n}\r\n\r\nexport function useRequestAnimationFrame(cb: AnimationFrame) {\r\n    const refCallback = useRef<AnimationFrame>(cb);\r\n    const refDeltaTime = useRef(0);\r\n\r\n    useEffect(() => {\r\n        refCallback.current = cb;\r\n    }, [cb]);\r\n    useEffect(() => {\r\n        let animationFrameId = 0;\r\n        const main = (time: number) => {\r\n            animationFrameId = window.requestAnimationFrame(main);\r\n            refCallback.current(time, time - refDeltaTime.current);\r\n            refDeltaTime.current = time;\r\n        }\r\n        animationFrameId = requestAnimationFrame((time) => {\r\n            refDeltaTime.current = time;\r\n            main(time);\r\n        });\r\n        return () => {\r\n            window.cancelAnimationFrame(animationFrameId);\r\n        };\r\n    }, []);\r\n}\r\n","export interface GLSLFunctions {\r\n    funcName: string;\r\n    value: string;\r\n    output: string;\r\n    input: string[];\r\n    dependencies?: GLSLFunctions[];\r\n}\r\nexport const random = (): GLSLFunctions => ({\r\n    funcName: 'random',\r\n    output: 'float',\r\n    input: ['vec2'],\r\n    value: `\r\nfloat random (in vec2 st) {\r\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\r\n}\r\n`,\r\n});\r\n\r\nexport const sigmoid = (): GLSLFunctions => ({\r\n    funcName: 'sigmoid',\r\n    output: 'float',\r\n    input: ['float', 'float', 'float'],\r\n    value: `\r\n// sigmoid関数 0-1\r\nfloat sigmoid(float a, float b, float x) {\r\n    return 1.0 / (1.0 + exp(-(a * x + b)));\r\n}\r\n`\r\n});\r\n\r\nexport const hsv2rgb = (): GLSLFunctions => ({\r\n    funcName: 'hsv2rgb',\r\n    output: 'vec3',\r\n    input: ['vec3'],\r\n    value: `\r\nvec3 hsv2rgb(vec3 c) {\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n`\r\n});\r\n\r\nexport const celluarNoise = (pointNum: number): GLSLFunctions => ({\r\n    funcName: 'cellular_noise',\r\n    output: 'float',\r\n    input: ['vec2', `vec2[${pointNum}]`],\r\n    value: `\r\n// ref https://thebookofshaders.com/12/?lan=jp\r\n// preview https://glslfan.com/\r\n// Author: @patriciogv\r\n// Title: 4 cells DF\r\n\r\nconst int celluar_point_num = ${pointNum};\r\nfloat cellular_noise(vec2 position, vec2[celluar_point_num] point) {\r\n    float m_dist = 1.0;\r\n    for (int i = 0; i < celluar_point_num; i++) {\r\n        float dist = distance(position, point[i]);\r\n        m_dist = min(m_dist, dist);\r\n    }\r\n    return m_dist;\r\n}\r\n`\r\n});\r\n\r\n\r\nexport const fci2d = (): GLSLFunctions => ({\r\n    funcName: 'fci2d',\r\n    output: 'float',\r\n    input: ['vec2'],\r\n    value: `\r\nfloat fci2d (vec2 st) {\r\n    vec2 i = floor(st);\r\n    vec2 f = fract(st);\r\n\r\n    // Four corners in 2D of a tile\r\n    float a = random(i);\r\n    float b = random(i + vec2(1.0, 0.0));\r\n    float c = random(i + vec2(0.0, 1.0));\r\n    float d = random(i + vec2(1.0, 1.0));\r\n\r\n    vec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(a, b, u.x) +\r\n            (c - a)* u.y * (1.0 - u.x) +\r\n            (d - b) * u.x * u.y;\r\n}\r\n`,\r\n});\r\n\r\ninterface FbmOptions {\r\n    noiseFunc?: GLSLFunctions,\r\n}\r\nexport const fbm = (octaves: number, {\r\n    noiseFunc = fci2d(),\r\n}: FbmOptions = {}): GLSLFunctions => ({\r\n    funcName: 'fbm',\r\n    output: 'float',\r\n    input: ['vec2'],\r\n    dependencies: [noiseFunc],\r\n    value: `\r\n// Based on Morgan McGuire @morgan3d\r\n// https://www.shadertoy.com/view/4dS3Wd\r\n\r\n#define FBM_OCTAVES ${octaves}\r\n#define FBM_NOISE ${noiseFunc.funcName}\r\nfloat fbm (in vec2 st) {\r\n    float value = 0.0;\r\n    float amplitude = .5;\r\n    float frequency = 0.;\r\n    for (int i = 0; i < FBM_OCTAVES; i++) {\r\n        value += amplitude * FBM_NOISE(st);\r\n        st *= 2.;\r\n        amplitude *= .5;\r\n    }\r\n    return value;\r\n}\r\n`\r\n});\r\n\r\nexport const simplex3d = (): GLSLFunctions => ({\r\n    funcName: 'simplex3d',\r\n    output: 'float',\r\n    input: ['vec3'],\r\n    dependencies: [random()],\r\n    value: `\r\nvec3 random3(vec3 c) {\r\n\tfloat j = 4096.0 * sin(dot(c,vec3(17.0, 59.4, 15.0)));\r\n\tvec3 r;\r\n\tr.z = fract(512.0 * j);\r\n\tj *= .125;\r\n\tr.x = fract(512.0 * j);\r\n\tj *= .125;\r\n\tr.y = fract(512.0 * j);\r\n\treturn r - 0.5;\r\n}\r\n\r\n/* 3d simplex noise */\r\nfloat simplex3d(vec3 p) {\r\n    const float F3 =  0.3333333;\r\n    const float G3 =  0.1666667;\r\n    const mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\r\n    const mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\r\n    const mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\r\n\t/* 1. find current tetrahedron T and it's four vertices */\r\n\t/* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\r\n\t/* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\r\n\t\r\n\t/* calculate s and x */\r\n\tvec3 s = floor(p + dot(p, vec3(F3)));\r\n\tvec3 x = p - s + dot(s, vec3(G3));\r\n\t\r\n\t/* calculate i1 and i2 */\r\n\tvec3 e = step(vec3(0.0), x - x.yzx);\r\n\tvec3 i1 = e*(1.0 - e.zxy);\r\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\r\n\t\t\r\n\t/* x1, x2, x3 */\r\n\tvec3 x1 = x - i1 + G3;\r\n\tvec3 x2 = x - i2 + 2.0 * G3;\r\n\tvec3 x3 = x - 1.0 + 3.0 * G3;\r\n\t\r\n\t/* 2. find four surflets and store them in d */\r\n\tvec4 w, d;\r\n\t\r\n\t/* calculate surflet weights */\r\n\tw.x = dot(x, x);\r\n\tw.y = dot(x1, x1);\r\n\tw.z = dot(x2, x2);\r\n\tw.w = dot(x3, x3);\r\n\t\r\n\t/* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\r\n\tw = max(0.6 - w, 0.0);\r\n\t\r\n\t/* calculate surflet components */\r\n\td.x = dot(random3(s), x);\r\n\td.y = dot(random3(s + i1), x1);\r\n\td.z = dot(random3(s + i2), x2);\r\n\td.w = dot(random3(s + 1.0), x3);\r\n\t\r\n\t/* multiply d by w^4 */\r\n\tw *= w;\r\n\tw *= w;\r\n\td *= w;\r\n\t\r\n\t/* 3. return the sum of the four surflets */\r\n\treturn dot(d, vec4(52.0));\r\n}\r\n`\r\n});\r\n\r\nexport const simplex3dFractal = (): GLSLFunctions => {\r\n    const simplex = simplex3d();\r\n    return ({\r\n        funcName: 'simplex3d_fractal',\r\n        output: 'float',\r\n        input: ['vec3'],\r\n        dependencies: [simplex],\r\n        value: `\r\nfloat simplex3d_fractal(vec3 m) {\r\n    const mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\r\n    const mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\r\n    const mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\r\n\r\n    return  0.5333333 * ${simplex.funcName}(m * rot1)\r\n        + 0.2666667 * ${simplex.funcName}(2.0 * m * rot2)\r\n        + 0.1333333 * ${simplex.funcName}(4.0 * m * rot3)\r\n        + 0.0666667 * ${simplex.funcName}(8.0 * m);\r\n}\r\n`\r\n    });\r\n};\r\nexport const simplex2dFractal = (): GLSLFunctions => {\r\n    const simplex = simplex3d();\r\n    return ({\r\n        funcName: 'simplex2d_fractal',\r\n        output: 'float',\r\n        input: ['vec3'],\r\n        dependencies: [simplex],\r\n        value: `\r\nfloat simplex2d_fractal(vec2 m) {\r\n    const mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\r\n    const mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\r\n    const mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\r\n\r\n    return  0.5333333 * ${simplex.funcName}(vec3(m, 1.0) * rot1)\r\n        + 0.2666667 * ${simplex.funcName}(2.0 * vec3(m, 1.0) * rot2)\r\n        + 0.1333333 * ${simplex.funcName}(4.0 *vec3(m, 1.0)*rot3)\r\n        + 0.0666667 * ${simplex.funcName}(8.0*vec3(m, 1.0));\r\n}\r\n`\r\n    });\r\n};\r\n\r\nexport const simplex2d = (): GLSLFunctions => {\r\n    const simplex = simplex3d();\r\n    return ({\r\n        funcName: 'simplex2d',\r\n        output: 'float',\r\n        input: ['vec2'],\r\n        dependencies: [simplex],\r\n        value: `\r\nfloat simplex2d(vec2 m) {\r\n    return simplex3d(vec3(m, 1.0));\r\n}\r\n`\r\n    });\r\n};\r\n\r\nexport const rotate2d = (): GLSLFunctions => ({\r\n    funcName: 'rotate2d',\r\n    output: 'mat2',\r\n    input: ['float'],\r\n    value: `\r\nmat2 rotate2d(float _angle){\r\n    return mat2(\r\n        cos(_angle),-sin(_angle),\r\n        sin(_angle),cos(_angle)\r\n    );\r\n}\r\n`,\r\n})\r\n\r\nexport const deserialize = (functions : GLSLFunctions[]): string => {\r\n    const map = new Map<string, string>();\r\n\r\n    const v = (functions : GLSLFunctions[]) => {\r\n        functions.forEach((value) => {\r\n            if (value.dependencies != null) {\r\n                v(value.dependencies);\r\n            }\r\n            map.set(value.funcName, value.value);\r\n        }, []);\r\n    };\r\n    v(functions);\r\n    return Array.from(map.entries()).map(val => (val[1])).join('\\n');\r\n};\r\n"],"names":["initialContext","renderer","scene","ThreeContext","createContext","useThreeContext","useContext","ThreeProvider","children","size","useState","setSize","resize","useCallback","width","window","innerWidth","height","innerHeight","useEffect","addEventListener","removeEventListener","useSize","elCanvas","useRef","threeRenderer","setThreeRenderer","useMemo","THREE","setPixelRatio","devicePixelRatio","current","Error","canvas","antialias","Provider","value","ref","fragmentShader","deserialize","random","simplex2d","fbm","noiseFunc","simplex2dFractal","hsv2rgb","rotate2d","OutMaterial","camera","useCamera","z","render","useRender","light","add","remove","light1","useDirectionalLight","x","y","intensity","color","useAddObject","light2","useShader","vertexShader","mesh","registerUniform","scale","updateUniformTime","look","useRequestAnimationFrame","time","lookAt","refCamera","position","refLight","set","fog","geometry","material","transparent","depthTest","key","initialValue","uniforms","parent","loopAnimation","cb","isCancel","id","main","requestAnimationFrame","cancelAnimationFrame","refCallback","refDeltaTime","animationFrameId","funcName","output","input","octaves","dependencies","simplex3d","simplex","functions","map","Map","v","forEach","Array","from","entries","val","join"],"sourceRoot":""}